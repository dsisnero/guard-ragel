require 'guard'
require 'guard/guard'
require 'guard/watcher'

module Guard
  class Ragel < Guard

    RagelError = Class.new(RuntimeError)

    OUTPUT_FORMATS = {
      :c => ['-C', 'c'],
      :d => ['-D', 'd'],
      :go => ['Z', 'go'],
      :java => ['J', 'java'],
      :ruby => ['-R', 'rb'],
      :csharp => ['-A', 'cs'],
      :ocaml => ['-O', 'caml'],
    }
  
    DEFAULTS = {
      :output_format => :ruby,       # Output format of ragel
      :options => '',                # Options to pass to ragel
      :notification => true,         # Enable notifications?
    }
    
    def initialize(watchers = [], options = {})
      super(watchers, DEFAULTS.merge(options))
    end

    # Runs ragel over the input file with specified options.
    #
    # @param file [String] path to file to build
    # @return [String] filename generated by running ragel
    #
    def build_ragel(file)
      # Determine name of the output file
      filename = File.basename(file, File.extname(file))
      output_dir = options[:output] || File.dir(file)
      output_extension = options[:extension] || format_options[1]
      output_file = File.join(output_dir, "#{filename}.#{output_extension}")

      # Flag to make the chosen format
      format_flag =  format_options[0]

      result = system "ragel #{options[:options]} #{format_flag} #{file} -o #{output_file}"
      raise RagelError, $? unless result

      output_file
    end
    
    # Build all files being watched
    def run_all
      run_on_change(Watcher.match_files(self, Dir.glob(File.join('**', '*.*'))))
    end
    
    # Build the files given
    def run_on_change(paths)
      changed_files = paths.reject{ |f| File.basename(f)[0] == "_" }.map do |file|
        begin
          output_file = build_ragel(file)
          ::Guard::UI.info " generated '#{output_file}' from '#{file}'", :reset => true
          ::Guard::Notifier.notify("rebuilt #{file}", :title => "Guard::Ragel", :image => :success) if options[:notification]
          output_file

        rescue RagelError => error
          ::Guard::UI.error "Ragel > #{error.message}"
          if options[:notification]
            ::Guard::Notifier.notify("rebuild failed > #{error.message}", :title => "Guard::Ragel", :image => :error) 
          end
          nil
        end
      end.compact
      notify changed_files
    end
    
    def notify(changed_files)
      ::Guard.guards.reject{ |guard| guard == self }.each do |guard|
        paths = Watcher.match_files(guard, changed_files)
        guard.run_on_change paths unless paths.empty?
      end
    end

  private #####################################################################

    def format_options
      format_type = options[:output_format]
      unless OUTPUT_FORMATS.key?(format_type)
        raise ArgumentError, "Unknown output format #{format_type}" 
      end
      OUTPUT_FORMATS[format_type]
    end

  end
end
