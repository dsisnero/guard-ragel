require 'guard'
require 'guard/guard'
require 'guard/watcher'

module Guard
  class Ragel < Guard

    RagelError = Class.new(RuntimeError)

    EXTENSIONS = {
      :c => 'c',
      :d => 'd',
      :go => 'go',
      :java => 'java',
      :ruby => 'rb',
      :csharp => 'cs',
      :ocaml => 'caml',
    }
    FORMAT_FLAGS = {
      'c' => '-C',
      'd' => '-D',
      'go' => '-Z',
      'java' => '-J',
      'rb' => '-R',
      'cs' => '-A',
      'caml' => '-O'
    }
  
    DEFAULTS = {
      :output_format => :ruby,       # Output format to use if it cannot be
                                     # determined from the original filename 
      :options => '',                # Options to pass to ragel
      :notification => true,         # Enable notifications?
      :extension => nil,             # Override output extension
    }
    
    def initialize(watchers = [], options = {})
      super(watchers, DEFAULTS.merge(options))
    end

    # Runs ragel over the input file with specified options.
    #
    # @param file [String] path to file to build
    # @return [String] filename generated by running ragel
    #
    def build_ragel(file)
      output_dir = options[:output] || File.dir(file)
      
      filename, extension = output_filename(file) 
      format_type = options[:output_format]
      extension ||= EXTENSIONS[format_type]
      if extension.nil?
        raise ArgumentError, "Unable to determine output format from #{filename} with default output #{format_type}" 
      end
      format_flag = FORMAT_FLAGS[extension]

      if override_extension = options[:extension]
        extension = override_extension
      end

      output_file = File.join(output_dir, "#{filename}.#{extension}")

      result = system "ragel #{options[:options]} #{format_flag} #{file} -o #{output_file}"
      raise RagelError, $? unless result

      output_file
    end
    
    # Build all files being watched
    def run_all
      run_on_change(Watcher.match_files(self, Dir.glob(File.join('**', '*.*'))))
    end
    
    # Build the files given
    def run_on_change(paths)
      changed_files = paths.reject{ |f| File.basename(f)[0] == "_" }.map do |file|

        begin
          output_file = build_ragel(file)
          message = "generated '#{output_file}' from '#{file}'"
          ::Guard::UI.info "Guard::Ragel -> #{message}", :reset => true
          if options[:notification]
            ::Guard::Notifier.notify(message, :title => "Guard::Ragel", :image => :success)
          end
          output_file

        rescue RagelError => error
          message = "failed to generate '#{output_file}' from '#{file}', error #{error.message}"
          ::Guard::UI.error "Guard::Ragel -> #{message}"
          if options[:notification]
            ::Guard::Notifier.notify(message, :title => "Guard::Ragel", :image => :error) 
          end
          nil

        end

      end.compact

      notify changed_files
    end
    
    def notify(changed_files)
      ::Guard.guards.reject{ |guard| guard == self }.each do |guard|
        paths = Watcher.match_files(guard, changed_files)
        guard.run_on_change paths unless paths.empty?
      end
    end

  private #####################################################################

    def output_filename(input_filename)
      basename = File.basename(input_filename, File.extname(input_filename))
      extension = File.extname(basename)

      if extension[0, 1].eql?('.')
        return [File.basename(basename, extension), extension.slice(1..-1)] 
      end
      [basename]
    end

  end
end
